#! /usr/bin/env python
#
# Copyright (c) 2020 Red Hat, Inc.
# This program and the accompanying materials are made
# available under the terms of the Eclipse Public License 2.0
# which is available at https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#

import sys
import os
import json
import requests
import subprocess
import yaml
import argparse

from packaging import version
from pathlib import Path

DESC_TEXT = "This is a small script which clones a Che plugin registry GitHub repository, \
    checks the versions of all the plugins, and determines which ones need to be updated. \
    Be sure to fill out REPO_OWNER, REPO_NAME, REPO_NAME_TO_FILE, and REPO_LABELS before running. \
    Your GitHub token can be added by exporting the GITHUB_TOKEN environment variable."
    


# Add arguments
parser = argparse.ArgumentParser(description = DESC_TEXT)
parser.add_argument("-f", "--file", help="file issues against the GitHub repo", action="store_true")
parser.add_argument("-s", "--silent", help="run this script silently without any report details", action="store_true")
args = parser.parse_args()


# NOTE: edit the fields below to customize where and how the script files issues
# Access token generated by GitHub
TOKEN = os.environ.get("GITHUB_TOKEN")
# The repository owner and name. This determines where the repository is
# cloned from.
REPO_OWNER = 'eclipse'
REPO_NAME = 'che-plugin-registry'
# Unlike the above, these determine the owner and name of the repository
# where any GitHub issues will be filed.
REPO_OWNER_TO_FILE = 'eclipse'
REPO_NAME_TO_FILE = 'che'
# Labels to be applied when filing issues
REPO_LABELS = ["automated", "area/plugins", "area/plugin-registry"]


# A dictionary containing all plugins in the plugin registry.
# The plug-in name is the key, and the value is a list of: 
#   [latest version in the registry, upstream extension URL]
PLUGIN_VERSION_DICT = {}

# Report strings that will be printed after the script runs.
PLUGINS_TO_UPDATE = "THE FOLLOWING PLUGINS NEED TO BE UPDATED\n"
PLUGINS_FAILED_TO_CHECK = "THE FOLLOWING PLUGINS WERE UNABLE TO BE CHECKED\n"
PLUGINS_UP_TO_DATE = "THE FOLLOWING PLUGINS ARE UP TO DATE\n"


def make_github_issue(title, body=None, labels=None):
    '''Create an issue on github.com using the given parameters.'''
    # Our url to create issues via POST
    url = 'https://api.github.com/repos/%s/%s/issues' % (REPO_OWNER_TO_FILE, REPO_NAME_TO_FILE)
    # Create an authenticated session to create the issue
    session = requests.Session()
    headers = {
        "Authorization": "token %s" % TOKEN,
    }
    # Create our issue
    issue = {"title": title,
             "body": body,
             "labels": labels}
    # File the issue
    r = session.post(url, json.dumps(issue), headers=headers)

    if r.status_code == 201:
        if not args.silent:
            print ("Successfully created Issue {0:s}".format(title))
    else:
        if not args.silent:
            print("Status code", r.status_code)
            print("Could not create Issue {0:s}".format(title))
            print("Response:", r.content)

def find_plugin_versions():
    '''Clone the repo, search it, and populate PLUGIN_VERSION_DICT with
    all plugin names, latest versions, and upstream repos.'''
    # Clone repo into the /tmp/ directory
    os.chdir("/tmp")
    os.system("git clone https://github.com/%s/%s.git" % (REPO_OWNER, REPO_NAME))
    os.chdir("/tmp/%s" % REPO_NAME)
    
    # Walk through the directory tree and seach for latest.txt files
    # Once found, the latest version for that plugin is stored in PLUGIN_VERSION_DICT
    for root, dirs, files in os.walk(".", topdown=False):
        for name in files:
            if (name == "latest.txt"):
                plugin_name = os.path.basename(root)
                latest = open(os.path.abspath(root) + "/" + name, 'r')
                plugin_latest = latest.readline().rstrip()
                latest.close()
                meta_yaml_location = os.path.abspath(root) + "/" + plugin_latest + "/meta.yaml"

                # Parse the plugins meta.yaml file and find the upstream repo where VS Code extension
                # is located.
                with open(meta_yaml_location) as f:
                    data = yaml.load(f, Loader=yaml.FullLoader)
                    PLUGIN_VERSION_DICT[plugin_name] = [plugin_latest, data['repository']]
                    f.close()

def check_plugins_for_updates():
    '''Iterate through all plugins in PLUGIN_VERSION_DICT and check if any of
    them need to be updated. If so, file an issue.'''
    global PLUGINS_TO_UPDATE
    global PLUGINS_FAILED_TO_CHECK
    global PLUGINS_UP_TO_DATE
    
    for k, v in PLUGIN_VERSION_DICT.items():
        if not args.silent:
            print("Checking ", k)
        if "github" not in v[1]:
            PLUGINS_FAILED_TO_CHECK = PLUGINS_FAILED_TO_CHECK + k + "\n"
            continue

        # Some repo names have a trailing slash, which needs to be removed
        split_url = v[1].split("/")
        if (split_url[-1] == ""):
            owner = split_url[-3]
            repo = split_url[-2]
        else:
            owner = split_url[-2]
            repo = split_url[-1]

        # Some repo names have a trailing .git, which needs to be removed
        if ".git" in repo:
            repo = repo.split(".git")[0]

        # Final URL to get repo data from
        url = 'https://api.github.com/repos/%s/%s/releases/latest' % (owner, repo)
        
        # Create an authenticated session to fetch repo data
        session = requests.Session()
        headers = {
            "Authorization": "token %s" % TOKEN,
        }
        r = session.get(url, headers=headers)

        if (r.status_code == 200):
            repo_data = r.json()
            # Sometimes the version will be specified in the "name" or "tag_name" fields.
            # We'll check for both just in case.
            if compare_versions(v[0], repo_data['name']):
                PLUGINS_TO_UPDATE = PLUGINS_TO_UPDATE + (k + " needs to be updated to " + repo_data['name']) + "\n"
                title = k + " needs to be updated to " + repo_data['name']
                body = "A new version of the " + k + " plugin is available upstream at:\n" + v[1]
                if args.file:
                    make_github_issue(title, body, REPO_LABELS)
            elif compare_versions(v[0], repo_data['tag_name']):
                PLUGINS_TO_UPDATE = PLUGINS_TO_UPDATE + (k + " needs to be updated to " + repo_data['tag_name']) + "\n"
                title = k + " needs to be updated to " + repo_data['tag_name']
                body = "A new version of the " + k + " plugin is available upstream at:\n" + v[1]
                if args.file:
                    make_github_issue(title, body, REPO_LABELS)
            else:
                PLUGINS_UP_TO_DATE = PLUGINS_UP_TO_DATE + k + "\n"
        else:
            PLUGINS_FAILED_TO_CHECK = PLUGINS_FAILED_TO_CHECK + k + "\n"
    
    # Update report messages
    PLUGINS_TO_UPDATE = PLUGINS_TO_UPDATE + "\n"
    PLUGINS_FAILED_TO_CHECK = PLUGINS_FAILED_TO_CHECK + "\n"
    PLUGINS_UP_TO_DATE = PLUGINS_UP_TO_DATE + "\n"

def compare_versions(base_version, compared_version):
    '''Return True if and only if base_version is less than compared_version.'''   
    # Make sure both inputs aren't None, and aren't empty
    if base_version and compared_version:
        if len(base_version) == 0 or len(compared_version) == 0:
            return False
        # Strip out any "v" characters in the version strings
        if base_version[0] == "v":
            base_version = base_version[1:]
        if compared_version[0] == "v":
            compared_version = compared_version[1:]
        return version.parse(base_version) < version.parse(compared_version)
    
    return False

def clean_up():
    '''Cleans the /tmp directory of the repo that was cloned.'''
    os.chdir("/tmp")
    os.system("rm -rf ./%s" % (REPO_NAME))

# Do not run the script if no token is provided
if not TOKEN:
    print("No GitHub token provided")
    sys.exit()

find_plugin_versions()
check_plugins_for_updates()
clean_up()

if not args.silent:
    print("\n" + PLUGINS_TO_UPDATE)
    print(PLUGINS_UP_TO_DATE)
    print(PLUGINS_FAILED_TO_CHECK)
